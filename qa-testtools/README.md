# qa-testtools

This library provides classes for testing applications. It provides classes for auto-generating bean properties, classes for mocking injectable interfaces, and an HTTP mock server for mimicking HTTP request/response cycles. It can be used to provide test data for ensuring unit tests execute under simulated live conditions. It can also be used to provide mock implementations of service interfaces during testing and development. It can also provide a live endpoint for testing HTTP calls during testing, useful for continuous integration testing scenarios in which the use of a live or test server is not possible. An example will be testing against a financial service API that requires configuration to mimic an error state.

##### Requirements
* Java 8+
* Maven

##### Quick Start

Add the QuakeArts.com maven repository

```
<repositories>
    <repository>
        <id>YOUR-PROJECT-NAME-mvn-repo</id>
        <url>https://raw.github.com/kwakutwumasi/Quakearts-Webtools/mvn-repo/</url>
    </repository>
</repositories>

```

then add the dependency

```
<dependency>
	<groupId>com.quakearts.webtools.test</groupId>
	<artifactId>qa-testtools</artifactId>
	<version>1.0.1</version>
</dependency>

```

###### Random Bean Property Generation

_com.quakearts.tools.test.generator.BeanGenerator_ is used to generate random bean properties. It scans beans  recursively for properties and creates generators for them. The _BeanGenerator_ libraries have generators for all primitive data types, their wrappers, _Strings_ and standard _Collection_s.
<br /><br />
Bean methods of a class can be annotated to modify random generation behavior. The _@com.quakearts.tools.test.generator.annotation.UseGeneratorProperty_ annotation points to a property in one of the generator property files that should be used when generating the bean property. Property files are available for configuring generators for dates, numbers and strings. The _@com.quakearts.tools.test.generator.annotation.Size_ annotation can be used to control the behavior of bean generation for _Collection_s. _@com.quakearts.tools.test.generator.annotation.NoGeneration_ annotation prevents a property from being generated. _@com.quakearts.tools.test.generator.annotation.CollectionType_ can be used for collections of abstract classes or interfaces to specify the concrete type to generate. 
<br /><br />
The _@NoGeneration_ and _@UseGeneratorProperty_ annotations can be specified programmatically for classes that cannot be modified with annotations. The _doNotGenerate()_ method marks a property as not generated and _useGeneratorProperty()_ points to the property in the generator property file to use for generation. Other methods provided can modify generation behaviour: the _use()_ and _forProperty()_ chain methods define a generator to use for a specific property:

```java

	beanGenerator.use(new MyGenerator()).forProperty("myfield");

```

The fluid API's should be called before the _init()_ method. Any call after _init()_ would have no effect.
<br /><br />
The _com.quakearts.tools.test.generator.factory.GeneratorFactory_ registers generators for each class type. Class types that do not have custom generators automatically default to the _BeanGenerator_ class as their generator. The _@com.quakearts.tools.test.generator.annotation.UseGenerator_ annotation can be used on a class to denote the _Generator_ class used to generate random objects of its type.
<br /><br />
To create custom bean generators, implement _com.quakearts.tools.test.generator.Generator_ or simply extend _com.quakearts.tools.test.generator.GeneratorBase_. _@com.quakearts.tools.test.generator.annotation.Generates_ annotation provides meta data on the class types that can be generated by the custom _Generator_.
<br /><br />
_com.quakearts.tools.test.generator.bootstrap.GeneratorBootstrap_ provides a method _init()_ which scans the classpath for _Generator_ implementations and registers them. This method is called automatically the first time _BeanGenerator_ is accessed. 

###### Mocking Interfaces

The popular Mockito Framework provides a robust tooling for generating mock objects. The mocking framework provided by these tools are much simpler and have a fewer dependencies. Mocking is limited to interfaces, since it uses the Java Proxy API to create mocked implementations of interfaces. This library is useful for projects that adhere strictly to using interfaces to enforce contracts between services and their clients, as opposed to concrete types. This programming model is popular in injection frameworks, where the concrete implementation is injected at runtime. As such the elaborate and complex mechanics of Mockito are not necessary. The Proxy API should suffice. Combined with CDI Alternatives, testing and developing applications without the need for fully functioning implementation classes should be a breeze.
<br /><br />
_com.quakearts.tools.test.mocking.proxy.MockingProxyBuilder_ can be used to create mock implementations of interfaces. _createMockingInvocationHandlerFor()_ method initiates the mock object creation. _mock()_ specifies the method to mock. The _with*()_ methods take lambda expressions of the mock action to take when the method specified is invoked on the mocked object. _with()_ can be used for methods that take arguments and have a return type. _withVoidMethod()_ can be used for methods that take arguments and have no return type. _withVoidEmptyMethod()_ can be used for methods that have no arguments and have no return type. Finally _withEmptyMethod()_ can be used for methods that take no arguments and have a return type.
<br /><br />
The _with*()_ methods can be used for mocking any method, regardless of its arguments or return type. Using the right method makes it possible to check the arguments used to call the mocked implementation and control the return type. The return type defaults to null if the method has a return type, but none is supplied.

An example of usage: 

```
	proxy = MockingProxyBuilder.createMockingInvocationHandlerFor(TestInterface.class)
				.mock("voidEmptyMethod").withVoidEmptyMethod(()->{
					
				}).mock("voidMethod(int,String,byte[],Double[])").withVoidMethod((arguments)->{
					assertThat(arguments.get(0), is(1));
					assertThat(arguments.get(1), is("test1"));
					assertThat(arguments.get(2), is(new byte[] {0x01b, 0x02b}));
					assertThat(arguments.get(3), is(new Double[] {1d, 2d}));
					assertThat(arguments.getMockedClass() == TestInterface.class, is(true));
				}).mock("emptyMethod").withEmptyMethod(()->{
					return "test2";
				}).mock("method(InputStream)").with((arguments)->{
					InputStream stream = arguments.get(0);
					if(stream == null)
						throw new IOException();
					
					return "test3";
				}).thenBuild();
```

###### Mocking Web Servers

_com.quakearts.tools.test.mockserver.MockServer_ provides methods for defining a mock server for simulating actual HTTP communication with a live server. This is useful in scenarios where making certain calls alter the state of the server in a way that requires resetting the server in order to repeat the behavior. A common use case would be a financial services test server which requires an account to be funded before executing a debit transaction. Ordinarily a separate call would need to be made to prepare the server for debit test cases. Using _MockServer_, a developer can record the interaction and then playback the interaction in subsequent tests of the code. It is also very useful for creating a sample API interface for other developers to code against, or a demo environment for clients to test the functionality of a user interface.
<br /><br />
_com.quakearts.tools.test.mockserver.MockServerFactory_ can be used to create instances of _MockServer_. It provides methods to define a _MockServer_ programmatically or through a Java property file.
<br /><br />
_com.quakearts.tools.test.mockserver.configuration.impl.ConfigurationBuilder_ is used to define the _com.quakearts.tools.test.mockserver.configuration.Configuration_ to use in creating the _MockServer_. it provides methods to configure the port, the URL to record and mock, and settings for TLS, if required by the project or a library.
<br /><br />
HTTP mock request and responses can also be defined using the methods in _MockServer_. The _add()_ method defines the _com.quakearts.tools.test.mockserver.model.MockAction_s to take when a request is processed. _com.quakearts.tools.test.mockserver.model.impl.MockActionBuilder_ is used to create _MockAction_s. It provides methods to define the HTTP request to match, the algorithm to use for matching incoming requests, and the actions to take before sending a response to the client. _com.quakearts.tools.test.mockserver.model.impl.HttpMessageBuilder_ can be used to create the _com.quakearts.tools.test.mockserver.model.HttpRequest_ and _com.quakearts.tools.test.mockserver.model.HttpResponse_ for the _MockAction_. _com.quakearts.tools.test.mockserver.fi.HttpResponseAction_  and _com.quakearts.tools.test.mockserver.fi.HttpRequestMatcher_  are functional interfaces, and can take lambda expressions.
<br /><br />
_MockServer_ operates in two modes: mocking mode and record mode. In record mode, it acts as a proxy: the http request is forwarded to a live URL; the response and the request that generated it is stored in a _com.quakearts.tools.test.mockserver.store.HttpMessageStore_. _HttpMessageStore_ provides methods for retrieving recorded requests and responses. Each record is given a unique id, generated from the request URL and uri parameters. The default _HttpMessageStore_ saves the request and responses in the _/http-messages_ folder at the root of the application path. The files are stored with a '.mock' extension. The files can be renamed without having any effect. Retrieving a file requires the name without the '.mock' extension passed as the ID parameter in the _findRequestIdentifiedBy()_ method.

An example of usage:

```java

MockServer mockServer = MockServerFactory.getInstance().getMockServer()
				.configure(ConfigurationBuilder
						.newConfiguration().setMockingModeAs(MockingMode.MOCK)
						.setURLToRecord("https://localhost:4080")
						.setPortAs(4082)
						.thenBuild())
				.add(MockActionBuilder.createNewMockAction()
						.setMatcherAs((httpRequest, httpRequestToMatch)->{
							return httpRequest.getResource().equals(httpRequestToMatch.getResource());
						})
						.setResponseActionAs((context, response)->{
							System.out.println("Responding...");
							return response;
						}).setRequestAs(HttpMessageBuilder
								.createNewHttpRequest()
								.setId("testId")
								.setMethodAs("GET")
								.setResourceAs("/test/mock")
								.addHeaders(new HttpHeaderImpl("Content-Type", "application/json"))
								.setResponseAs(HttpMessageBuilder
									.createNewHttpResponse()
									.setContentBytes("{\"status\":\"ok\"}".getBytes())
									.setResponseCodeAs(200)
									.addHeaders(new HttpHeaderImpl("Content-Type", "application/json"))
									.thenBuild())
								.thenBuild())
						.thenBuild())
				.add(MockActionBuilder.createNewMockAction()
						.setMatcherAs((httpRequest, httpRequestToMatch)->{
							return httpRequest.getResource().equals(httpRequestToMatch.getResource());
						}).setRequestAs(HttpMessageBuilder
								.createNewHttpRequest()
								.setId("testId")
								.setMethodAs("POST")
								.setResourceAs("/test/mock/default")
								.setContentBytes("{\"test\":\"value\"}".getBytes())
								.addHeaders(new HttpHeaderImpl("Content-Type", "application/json"))
								.setResponseAs(HttpMessageBuilder
									.createNewHttpResponse()
									.setContentBytes("{\"status\":\"ok\"}".getBytes())
									.setResponseCodeAs(200)
									.addHeaders(new HttpHeaderImpl("Content-Type", "application/json"),
											new HttpHeaderImpl("Set-Cookie", Arrays.asList("Cookie=Cookie1", "Cookie=Cookie2")))
									.thenBuild())
								.thenBuild())
						.thenBuild());
						
			mockServer.start();

```

